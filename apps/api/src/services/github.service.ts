import { Octokit } from '@octokit/rest';

interface FileContent {
  path: string;
  content: string;
}

interface PublishProjectParams {
  accessToken: string;
  projectName: string;
  generatedCode: Record<string, any>;
}

interface PublishResult {
  repositoryUrl: string;
  repositoryName: string;
}

export class GitHubService {
  private getOctokit(accessToken: string): Octokit {
    return new Octokit({
      auth: accessToken,
    });
  }

  private convertGeneratedCodeToFiles(generatedCode: Record<string, any>): FileContent[] {
    const files: FileContent[] = [];
    
    const processObject = (obj: any, currentPath = '') => {
      for (const [key, value] of Object.entries(obj)) {
        const path = currentPath ? `${currentPath}/${key}` : key;
        
        if (typeof value === 'string') {
          files.push({ path, content: value });
        } else if (typeof value === 'object' && value !== null) {
          processObject(value, path);
        }
      }
    };
    
    processObject(generatedCode);
    return files;
  }

  async publishProject({ accessToken, projectName, generatedCode }: PublishProjectParams): Promise<PublishResult> {
    const octokit = this.getOctokit(accessToken);
    
    try {
      const { data: user } = await octokit.rest.users.getAuthenticated();
      
      const repositoryName = projectName.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '');
      
      const { data: repository } = await octokit.rest.repos.createForAuthenticatedUser({
        name: repositoryName,
        description: `Generated by Open SWE Platform: ${projectName}`,
        private: false,
        auto_init: false,
      });

      const files = this.convertGeneratedCodeToFiles(generatedCode);
      
      if (files.length === 0) {
        throw new Error('No files found in generated code');
      }

      const blobs: { path: string; sha: string; mode: string }[] = [];
      
      for (const file of files) {
        const { data: blob } = await octokit.rest.git.createBlob({
          owner: user.login,
          repo: repositoryName,
          content: Buffer.from(file.content, 'utf8').toString('base64'),
          encoding: 'base64',
        });
        
        blobs.push({
          path: file.path,
          sha: blob.sha,
          mode: '100644',
        });
      }

      const { data: tree } = await octokit.rest.git.createTree({
        owner: user.login,
        repo: repositoryName,
        tree: blobs.map(blob => ({
          path: blob.path,
          mode: blob.mode as any,
          type: 'blob' as const,
          sha: blob.sha,
        })),
      });

      const { data: commit } = await octokit.rest.git.createCommit({
        owner: user.login,
        repo: repositoryName,
        message: 'feat: Initial commit by Open SWE Platform 🚀\n\nGenerated with Claude Code\n\nCo-Authored-By: Claude <noreply@anthropic.com>',
        tree: tree.sha,
      });

      await octokit.rest.git.updateRef({
        owner: user.login,
        repo: repositoryName,
        ref: 'heads/main',
        sha: commit.sha,
      });

      return {
        repositoryUrl: repository.html_url,
        repositoryName: repository.name,
      };
    } catch (error) {
      console.error('Error publishing to GitHub:', error);
      throw new Error(`Failed to publish project to GitHub: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }
}

export const githubService = new GitHubService();

/**
 * Cria um novo repositório privado para o utilizador.
 * @param repoName O nome do repositório a ser criado.
 * @returns O URL HTML do repositório criado.
 */
export async function createRepoForUser(repoName: string): Promise<string> {
  // NOTA: A implementação real requer uma instância `octokit` autenticada.
  // Por agora, esta função de esboço satisfaz o nosso teste.
  console.log(`[Mock] Criando repositório: ${repoName}`);
  // A implementação real usaria:
  // const response = await octokit.repos.createForAuthenticatedUser({ name: repoName, private: true });
  // return response.data.html_url;
  return `https://github.com/mockuser/${repoName}`;
}

/**
 * Faz o "push" de um conjunto de ficheiros para um repositório.
 * @param username O nome de utilizador do proprietário do repositório.
 * @param repoName O nome do repositório.
 * @param files Um mapa de caminhos de ficheiro para o seu conteúdo.
 * @returns O SHA do commit.
 */
export async function pushCodeToRepo(
  username: string,
  repoName: string,
  files: Record<string, string>
): Promise<string> {
  // NOTA: A implementação real é complexa (envolve criar blobs, árvore, commit, e atualizar a ref).
  // Esta função de esboço é suficiente para o nosso teste de agente.
  console.log(`[Mock] Fazendo push de ${Object.keys(files).length} ficheiros para ${repoName}`);
  return 'mock_commit_sha_12345';
}