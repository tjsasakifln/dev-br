import { GitHubService, createRepoForUser, pushCodeToRepo } from './github.service';
import { Octokit } from '@octokit/rest';

jest.mock('@octokit/rest', () => {
  return {
    Octokit: jest.fn(),
  };
});

const mockOctokit = {
  rest: {
    users: {
      getAuthenticated: jest.fn(),
    },
    repos: {
      createForAuthenticatedUser: jest.fn(),
    },
    git: {
      createBlob: jest.fn(),
      createTree: jest.fn(),
      createCommit: jest.fn(),
      updateRef: jest.fn(),
    },
  },
};

const MockedOctokit = Octokit as jest.MockedClass<typeof Octokit>;
MockedOctokit.mockImplementation(() => mockOctokit as any);

describe('GitHubService', () => {
  let githubService: GitHubService;

  beforeEach(() => {
    githubService = new GitHubService();
    jest.clearAllMocks();
  });

  describe('convertGeneratedCodeToFiles', () => {
    it('should convert a flat object to file array', () => {
      const generatedCode = {
        'package.json': '{"name": "test"}',
        'src/App.tsx': 'export default function App() { return <div>Hello</div>; }',
        'README.md': '# Test Project',
      };

      const result = (githubService as any).convertGeneratedCodeToFiles(generatedCode);

      expect(result).toEqual([
        { path: 'package.json', content: '{"name": "test"}' },
        { path: 'src/App.tsx', content: 'export default function App() { return <div>Hello</div>; }' },
        { path: 'README.md', content: '# Test Project' },
      ]);
    });

    it('should convert nested objects to file paths', () => {
      const generatedCode = {
        src: {
          components: {
            'Button.tsx': 'export const Button = () => <button />;',
          },
          'App.tsx': 'export default function App() { return <div>Hello</div>; }',
        },
        'package.json': '{"name": "test"}',
      };

      const result = (githubService as any).convertGeneratedCodeToFiles(generatedCode);

      expect(result).toEqual([
        { path: 'src/components/Button.tsx', content: 'export const Button = () => <button />;' },
        { path: 'src/App.tsx', content: 'export default function App() { return <div>Hello</div>; }' },
        { path: 'package.json', content: '{"name": "test"}' },
      ]);
    });

    it('should handle empty object', () => {
      const generatedCode = {};
      const result = (githubService as any).convertGeneratedCodeToFiles(generatedCode);
      expect(result).toEqual([]);
    });
  });

  describe('publishProject', () => {
    const mockUser = { login: 'testuser', id: 123 };
    const mockRepo = {
      name: 'test-project',
      html_url: 'https://github.com/testuser/test-project',
    };
    const mockBlob = { sha: 'blob123' };
    const mockTree = { sha: 'tree123' };
    const mockCommit = { sha: 'commit123' };

    const publishParams = {
      accessToken: 'test-token',
      projectName: 'Test Project',
      generatedCode: {
        'package.json': '{"name": "test"}',
        'src/App.tsx': 'export default function App() { return <div>Hello</div>; }',
      },
    };

    beforeEach(() => {
      mockOctokit.rest.users.getAuthenticated.mockResolvedValue({ data: mockUser });
      mockOctokit.rest.repos.createForAuthenticatedUser.mockResolvedValue({ data: mockRepo });
      mockOctokit.rest.git.createBlob.mockResolvedValue({ data: mockBlob });
      mockOctokit.rest.git.createTree.mockResolvedValue({ data: mockTree });
      mockOctokit.rest.git.createCommit.mockResolvedValue({ data: mockCommit });
      mockOctokit.rest.git.updateRef.mockResolvedValue({});
    });

    it('should successfully publish project to GitHub', async () => {
      const result = await githubService.publishProject(publishParams);

      expect(mockOctokit.rest.users.getAuthenticated).toHaveBeenCalledTimes(1);
      expect(mockOctokit.rest.repos.createForAuthenticatedUser).toHaveBeenCalledWith({
        name: 'test-project',
        description: 'Generated by Open SWE Platform: Test Project',
        private: false,
        auto_init: false,
      });

      expect(mockOctokit.rest.git.createBlob).toHaveBeenCalledTimes(2);
      expect(mockOctokit.rest.git.createTree).toHaveBeenCalledTimes(1);
      expect(mockOctokit.rest.git.createCommit).toHaveBeenCalledWith({
        owner: 'testuser',
        repo: 'test-project',
        message: 'feat: Initial commit by Open SWE Platform ðŸš€\n\nGenerated with Claude Code\n\nCo-Authored-By: Claude <noreply@anthropic.com>',
        tree: 'tree123',
      });
      expect(mockOctokit.rest.git.updateRef).toHaveBeenCalledWith({
        owner: 'testuser',
        repo: 'test-project',
        ref: 'heads/main',
        sha: 'commit123',
      });

      expect(result).toEqual({
        repositoryUrl: 'https://github.com/testuser/test-project',
        repositoryName: 'test-project',
      });
    });

    it('should normalize repository name correctly', async () => {
      const params = {
        ...publishParams,
        projectName: 'My Awesome App! @#$%',
      };

      await githubService.publishProject(params);

      expect(mockOctokit.rest.repos.createForAuthenticatedUser).toHaveBeenCalledWith({
        name: 'my-awesome-app-',
        description: 'Generated by Open SWE Platform: My Awesome App! @#$%',
        private: false,
        auto_init: false,
      });
    });

    it('should handle empty generated code', async () => {
      const params = {
        ...publishParams,
        generatedCode: {},
      };

      await expect(githubService.publishProject(params)).rejects.toThrow(
        'No files found in generated code'
      );

      expect(mockOctokit.rest.users.getAuthenticated).toHaveBeenCalledTimes(1);
      expect(mockOctokit.rest.repos.createForAuthenticatedUser).toHaveBeenCalledTimes(1);
      expect(mockOctokit.rest.git.createBlob).not.toHaveBeenCalled();
    });

    it('should handle invalid access token', async () => {
      const error = new Error('Bad credentials');
      mockOctokit.rest.users.getAuthenticated.mockRejectedValue(error);

      await expect(githubService.publishProject(publishParams)).rejects.toThrow(
        'Failed to publish project to GitHub: Bad credentials'
      );

      expect(mockOctokit.rest.users.getAuthenticated).toHaveBeenCalledTimes(1);
      expect(mockOctokit.rest.repos.createForAuthenticatedUser).not.toHaveBeenCalled();
    });

    it('should handle repository name already exists', async () => {
      const error = new Error('Repository creation failed');
      error.name = 'HttpError';
      (error as any).status = 422;
      mockOctokit.rest.repos.createForAuthenticatedUser.mockRejectedValue(error);

      await expect(githubService.publishProject(publishParams)).rejects.toThrow(
        'Failed to publish project to GitHub: Repository creation failed'
      );

      expect(mockOctokit.rest.users.getAuthenticated).toHaveBeenCalledTimes(1);
      expect(mockOctokit.rest.repos.createForAuthenticatedUser).toHaveBeenCalledTimes(1);
      expect(mockOctokit.rest.git.createBlob).not.toHaveBeenCalled();
    });

    it('should handle blob creation failure', async () => {
      const error = new Error('Blob creation failed');
      mockOctokit.rest.git.createBlob.mockRejectedValue(error);

      await expect(githubService.publishProject(publishParams)).rejects.toThrow(
        'Failed to publish project to GitHub: Blob creation failed'
      );

      expect(mockOctokit.rest.users.getAuthenticated).toHaveBeenCalledTimes(1);
      expect(mockOctokit.rest.repos.createForAuthenticatedUser).toHaveBeenCalledTimes(1);
      expect(mockOctokit.rest.git.createBlob).toHaveBeenCalledTimes(1);
      expect(mockOctokit.rest.git.createTree).not.toHaveBeenCalled();
    });

    it('should handle tree creation failure', async () => {
      const error = new Error('Tree creation failed');
      mockOctokit.rest.git.createTree.mockRejectedValue(error);

      await expect(githubService.publishProject(publishParams)).rejects.toThrow(
        'Failed to publish project to GitHub: Tree creation failed'
      );

      expect(mockOctokit.rest.git.createBlob).toHaveBeenCalledTimes(2);
      expect(mockOctokit.rest.git.createTree).toHaveBeenCalledTimes(1);
      expect(mockOctokit.rest.git.createCommit).not.toHaveBeenCalled();
    });

    it('should handle commit creation failure', async () => {
      const error = new Error('Commit creation failed');
      mockOctokit.rest.git.createCommit.mockRejectedValue(error);

      await expect(githubService.publishProject(publishParams)).rejects.toThrow(
        'Failed to publish project to GitHub: Commit creation failed'
      );

      expect(mockOctokit.rest.git.createBlob).toHaveBeenCalledTimes(2);
      expect(mockOctokit.rest.git.createTree).toHaveBeenCalledTimes(1);
      expect(mockOctokit.rest.git.createCommit).toHaveBeenCalledTimes(1);
      expect(mockOctokit.rest.git.updateRef).not.toHaveBeenCalled();
    });

    it('should handle ref update failure', async () => {
      const error = new Error('Ref update failed');
      mockOctokit.rest.git.updateRef.mockRejectedValue(error);

      await expect(githubService.publishProject(publishParams)).rejects.toThrow(
        'Failed to publish project to GitHub: Ref update failed'
      );

      expect(mockOctokit.rest.git.createBlob).toHaveBeenCalledTimes(2);
      expect(mockOctokit.rest.git.createTree).toHaveBeenCalledTimes(1);
      expect(mockOctokit.rest.git.createCommit).toHaveBeenCalledTimes(1);
      expect(mockOctokit.rest.git.updateRef).toHaveBeenCalledTimes(1);
    });
  });

  describe('createRepoForUser', () => {
    it('should return mock repository URL', async () => {
      const result = await createRepoForUser('test-repo');
      expect(result).toBe('https://github.com/mockuser/test-repo');
    });

    it('should log the repository creation', async () => {
      const consoleSpy = jest.spyOn(console, 'log').mockImplementation();
      await createRepoForUser('my-awesome-repo');
      expect(consoleSpy).toHaveBeenCalledWith('[Mock] Criando repositÃ³rio: my-awesome-repo');
      consoleSpy.mockRestore();
    });
  });

  describe('pushCodeToRepo', () => {
    it('should return mock commit SHA', async () => {
      const files = {
        'package.json': '{"name": "test"}',
        'src/App.tsx': 'export default function App() { return <div>Hello</div>; }',
      };

      const result = await pushCodeToRepo('testuser', 'test-repo', files);
      expect(result).toBe('mock_commit_sha_12345');
    });

    it('should log the push operation', async () => {
      const consoleSpy = jest.spyOn(console, 'log').mockImplementation();
      const files = {
        'file1.txt': 'content1',
        'file2.txt': 'content2',
      };

      await pushCodeToRepo('testuser', 'test-repo', files);
      expect(consoleSpy).toHaveBeenCalledWith('[Mock] Fazendo push de 2 ficheiros para test-repo');
      consoleSpy.mockRestore();
    });

    it('should handle empty files object', async () => {
      const result = await pushCodeToRepo('testuser', 'test-repo', {});
      expect(result).toBe('mock_commit_sha_12345');
    });
  });
});